// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
class CSEchoReq;
struct CSEchoReqDefaultTypeInternal;
extern CSEchoReqDefaultTypeInternal _CSEchoReq_default_instance_;
class CSEnterGameReq;
struct CSEnterGameReqDefaultTypeInternal;
extern CSEnterGameReqDefaultTypeInternal _CSEnterGameReq_default_instance_;
class CSMoveReq;
struct CSMoveReqDefaultTypeInternal;
extern CSMoveReqDefaultTypeInternal _CSMoveReq_default_instance_;
class CSStopReq;
struct CSStopReqDefaultTypeInternal;
extern CSStopReqDefaultTypeInternal _CSStopReq_default_instance_;
class SCEchoAck;
struct SCEchoAckDefaultTypeInternal;
extern SCEchoAckDefaultTypeInternal _SCEchoAck_default_instance_;
class SCEnterGameAck;
struct SCEnterGameAckDefaultTypeInternal;
extern SCEnterGameAckDefaultTypeInternal _SCEnterGameAck_default_instance_;
class SCEnterGameNoti;
struct SCEnterGameNotiDefaultTypeInternal;
extern SCEnterGameNotiDefaultTypeInternal _SCEnterGameNoti_default_instance_;
class SCMoveNoti;
struct SCMoveNotiDefaultTypeInternal;
extern SCMoveNotiDefaultTypeInternal _SCMoveNoti_default_instance_;
class SCStopNoti;
struct SCStopNotiDefaultTypeInternal;
extern SCStopNotiDefaultTypeInternal _SCStopNoti_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CSEchoReq* Arena::CreateMaybeMessage<::CSEchoReq>(Arena*);
template<> ::CSEnterGameReq* Arena::CreateMaybeMessage<::CSEnterGameReq>(Arena*);
template<> ::CSMoveReq* Arena::CreateMaybeMessage<::CSMoveReq>(Arena*);
template<> ::CSStopReq* Arena::CreateMaybeMessage<::CSStopReq>(Arena*);
template<> ::SCEchoAck* Arena::CreateMaybeMessage<::SCEchoAck>(Arena*);
template<> ::SCEnterGameAck* Arena::CreateMaybeMessage<::SCEnterGameAck>(Arena*);
template<> ::SCEnterGameNoti* Arena::CreateMaybeMessage<::SCEnterGameNoti>(Arena*);
template<> ::SCMoveNoti* Arena::CreateMaybeMessage<::SCMoveNoti>(Arena*);
template<> ::SCStopNoti* Arena::CreateMaybeMessage<::SCStopNoti>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class CSEchoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSEchoReq) */ {
 public:
  inline CSEchoReq() : CSEchoReq(nullptr) {}
  ~CSEchoReq() override;
  explicit PROTOBUF_CONSTEXPR CSEchoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSEchoReq(const CSEchoReq& from);
  CSEchoReq(CSEchoReq&& from) noexcept
    : CSEchoReq() {
    *this = ::std::move(from);
  }

  inline CSEchoReq& operator=(const CSEchoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSEchoReq& operator=(CSEchoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSEchoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSEchoReq* internal_default_instance() {
    return reinterpret_cast<const CSEchoReq*>(
               &_CSEchoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CSEchoReq& a, CSEchoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CSEchoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSEchoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSEchoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSEchoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSEchoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CSEchoReq& from) {
    CSEchoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSEchoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSEchoReq";
  }
  protected:
  explicit CSEchoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:CSEchoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SCEchoAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SCEchoAck) */ {
 public:
  inline SCEchoAck() : SCEchoAck(nullptr) {}
  ~SCEchoAck() override;
  explicit PROTOBUF_CONSTEXPR SCEchoAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCEchoAck(const SCEchoAck& from);
  SCEchoAck(SCEchoAck&& from) noexcept
    : SCEchoAck() {
    *this = ::std::move(from);
  }

  inline SCEchoAck& operator=(const SCEchoAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCEchoAck& operator=(SCEchoAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCEchoAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCEchoAck* internal_default_instance() {
    return reinterpret_cast<const SCEchoAck*>(
               &_SCEchoAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SCEchoAck& a, SCEchoAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SCEchoAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCEchoAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCEchoAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCEchoAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCEchoAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCEchoAck& from) {
    SCEchoAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCEchoAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SCEchoAck";
  }
  protected:
  explicit SCEchoAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:SCEchoAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CSEnterGameReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSEnterGameReq) */ {
 public:
  inline CSEnterGameReq() : CSEnterGameReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CSEnterGameReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSEnterGameReq(const CSEnterGameReq& from);
  CSEnterGameReq(CSEnterGameReq&& from) noexcept
    : CSEnterGameReq() {
    *this = ::std::move(from);
  }

  inline CSEnterGameReq& operator=(const CSEnterGameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSEnterGameReq& operator=(CSEnterGameReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSEnterGameReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSEnterGameReq* internal_default_instance() {
    return reinterpret_cast<const CSEnterGameReq*>(
               &_CSEnterGameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CSEnterGameReq& a, CSEnterGameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CSEnterGameReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSEnterGameReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSEnterGameReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSEnterGameReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSEnterGameReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSEnterGameReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSEnterGameReq";
  }
  protected:
  explicit CSEnterGameReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSEnterGameReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SCEnterGameAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SCEnterGameAck) */ {
 public:
  inline SCEnterGameAck() : SCEnterGameAck(nullptr) {}
  ~SCEnterGameAck() override;
  explicit PROTOBUF_CONSTEXPR SCEnterGameAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCEnterGameAck(const SCEnterGameAck& from);
  SCEnterGameAck(SCEnterGameAck&& from) noexcept
    : SCEnterGameAck() {
    *this = ::std::move(from);
  }

  inline SCEnterGameAck& operator=(const SCEnterGameAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCEnterGameAck& operator=(SCEnterGameAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCEnterGameAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCEnterGameAck* internal_default_instance() {
    return reinterpret_cast<const SCEnterGameAck*>(
               &_SCEnterGameAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SCEnterGameAck& a, SCEnterGameAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SCEnterGameAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCEnterGameAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCEnterGameAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCEnterGameAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCEnterGameAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCEnterGameAck& from) {
    SCEnterGameAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCEnterGameAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SCEnterGameAck";
  }
  protected:
  explicit SCEnterGameAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float X = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float Y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:SCEnterGameAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SCEnterGameNoti final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SCEnterGameNoti) */ {
 public:
  inline SCEnterGameNoti() : SCEnterGameNoti(nullptr) {}
  ~SCEnterGameNoti() override;
  explicit PROTOBUF_CONSTEXPR SCEnterGameNoti(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCEnterGameNoti(const SCEnterGameNoti& from);
  SCEnterGameNoti(SCEnterGameNoti&& from) noexcept
    : SCEnterGameNoti() {
    *this = ::std::move(from);
  }

  inline SCEnterGameNoti& operator=(const SCEnterGameNoti& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCEnterGameNoti& operator=(SCEnterGameNoti&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCEnterGameNoti& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCEnterGameNoti* internal_default_instance() {
    return reinterpret_cast<const SCEnterGameNoti*>(
               &_SCEnterGameNoti_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SCEnterGameNoti& a, SCEnterGameNoti& b) {
    a.Swap(&b);
  }
  inline void Swap(SCEnterGameNoti* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCEnterGameNoti* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCEnterGameNoti* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCEnterGameNoti>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCEnterGameNoti& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCEnterGameNoti& from) {
    SCEnterGameNoti::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCEnterGameNoti* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SCEnterGameNoti";
  }
  protected:
  explicit SCEnterGameNoti(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueIDFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kIsMoveFieldNumber = 3,
    kXFieldNumber = 4,
    kYFieldNumber = 5,
  };
  // int64 UniqueID = 1;
  void clear_uniqueid();
  int64_t uniqueid() const;
  void set_uniqueid(int64_t value);
  private:
  int64_t _internal_uniqueid() const;
  void _internal_set_uniqueid(int64_t value);
  public:

  // int32 Direction = 2;
  void clear_direction();
  int32_t direction() const;
  void set_direction(int32_t value);
  private:
  int32_t _internal_direction() const;
  void _internal_set_direction(int32_t value);
  public:

  // bool IsMove = 3;
  void clear_ismove();
  bool ismove() const;
  void set_ismove(bool value);
  private:
  bool _internal_ismove() const;
  void _internal_set_ismove(bool value);
  public:

  // float X = 4;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float Y = 5;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:SCEnterGameNoti)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t uniqueid_;
    int32_t direction_;
    bool ismove_;
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CSMoveReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSMoveReq) */ {
 public:
  inline CSMoveReq() : CSMoveReq(nullptr) {}
  ~CSMoveReq() override;
  explicit PROTOBUF_CONSTEXPR CSMoveReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSMoveReq(const CSMoveReq& from);
  CSMoveReq(CSMoveReq&& from) noexcept
    : CSMoveReq() {
    *this = ::std::move(from);
  }

  inline CSMoveReq& operator=(const CSMoveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSMoveReq& operator=(CSMoveReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSMoveReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSMoveReq* internal_default_instance() {
    return reinterpret_cast<const CSMoveReq*>(
               &_CSMoveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CSMoveReq& a, CSMoveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CSMoveReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSMoveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSMoveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSMoveReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSMoveReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CSMoveReq& from) {
    CSMoveReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSMoveReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSMoveReq";
  }
  protected:
  explicit CSMoveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
  };
  // int32 Direction = 1;
  void clear_direction();
  int32_t direction() const;
  void set_direction(int32_t value);
  private:
  int32_t _internal_direction() const;
  void _internal_set_direction(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSMoveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SCMoveNoti final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SCMoveNoti) */ {
 public:
  inline SCMoveNoti() : SCMoveNoti(nullptr) {}
  ~SCMoveNoti() override;
  explicit PROTOBUF_CONSTEXPR SCMoveNoti(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCMoveNoti(const SCMoveNoti& from);
  SCMoveNoti(SCMoveNoti&& from) noexcept
    : SCMoveNoti() {
    *this = ::std::move(from);
  }

  inline SCMoveNoti& operator=(const SCMoveNoti& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCMoveNoti& operator=(SCMoveNoti&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCMoveNoti& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCMoveNoti* internal_default_instance() {
    return reinterpret_cast<const SCMoveNoti*>(
               &_SCMoveNoti_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SCMoveNoti& a, SCMoveNoti& b) {
    a.Swap(&b);
  }
  inline void Swap(SCMoveNoti* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCMoveNoti* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCMoveNoti* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCMoveNoti>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCMoveNoti& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCMoveNoti& from) {
    SCMoveNoti::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCMoveNoti* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SCMoveNoti";
  }
  protected:
  explicit SCMoveNoti(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueIDFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
  };
  // int64 UniqueID = 1;
  void clear_uniqueid();
  int64_t uniqueid() const;
  void set_uniqueid(int64_t value);
  private:
  int64_t _internal_uniqueid() const;
  void _internal_set_uniqueid(int64_t value);
  public:

  // int32 Direction = 2;
  void clear_direction();
  int32_t direction() const;
  void set_direction(int32_t value);
  private:
  int32_t _internal_direction() const;
  void _internal_set_direction(int32_t value);
  public:

  // float X = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float Y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:SCMoveNoti)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t uniqueid_;
    int32_t direction_;
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CSStopReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSStopReq) */ {
 public:
  inline CSStopReq() : CSStopReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CSStopReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSStopReq(const CSStopReq& from);
  CSStopReq(CSStopReq&& from) noexcept
    : CSStopReq() {
    *this = ::std::move(from);
  }

  inline CSStopReq& operator=(const CSStopReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSStopReq& operator=(CSStopReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSStopReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSStopReq* internal_default_instance() {
    return reinterpret_cast<const CSStopReq*>(
               &_CSStopReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CSStopReq& a, CSStopReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CSStopReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSStopReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSStopReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSStopReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSStopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSStopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSStopReq";
  }
  protected:
  explicit CSStopReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSStopReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SCStopNoti final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SCStopNoti) */ {
 public:
  inline SCStopNoti() : SCStopNoti(nullptr) {}
  ~SCStopNoti() override;
  explicit PROTOBUF_CONSTEXPR SCStopNoti(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCStopNoti(const SCStopNoti& from);
  SCStopNoti(SCStopNoti&& from) noexcept
    : SCStopNoti() {
    *this = ::std::move(from);
  }

  inline SCStopNoti& operator=(const SCStopNoti& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCStopNoti& operator=(SCStopNoti&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCStopNoti& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCStopNoti* internal_default_instance() {
    return reinterpret_cast<const SCStopNoti*>(
               &_SCStopNoti_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SCStopNoti& a, SCStopNoti& b) {
    a.Swap(&b);
  }
  inline void Swap(SCStopNoti* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCStopNoti* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCStopNoti* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCStopNoti>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCStopNoti& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCStopNoti& from) {
    SCStopNoti::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCStopNoti* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SCStopNoti";
  }
  protected:
  explicit SCStopNoti(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueIDFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // int64 UniqueID = 1;
  void clear_uniqueid();
  int64_t uniqueid() const;
  void set_uniqueid(int64_t value);
  private:
  int64_t _internal_uniqueid() const;
  void _internal_set_uniqueid(int64_t value);
  public:

  // float X = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float Y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:SCStopNoti)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t uniqueid_;
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CSEchoReq

// string text = 1;
inline void CSEchoReq::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& CSEchoReq::text() const {
  // @@protoc_insertion_point(field_get:CSEchoReq.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSEchoReq::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSEchoReq.text)
}
inline std::string* CSEchoReq::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:CSEchoReq.text)
  return _s;
}
inline const std::string& CSEchoReq::_internal_text() const {
  return _impl_.text_.Get();
}
inline void CSEchoReq::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* CSEchoReq::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* CSEchoReq::release_text() {
  // @@protoc_insertion_point(field_release:CSEchoReq.text)
  return _impl_.text_.Release();
}
inline void CSEchoReq::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSEchoReq.text)
}

// -------------------------------------------------------------------

// SCEchoAck

// string text = 1;
inline void SCEchoAck::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& SCEchoAck::text() const {
  // @@protoc_insertion_point(field_get:SCEchoAck.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCEchoAck::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SCEchoAck.text)
}
inline std::string* SCEchoAck::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:SCEchoAck.text)
  return _s;
}
inline const std::string& SCEchoAck::_internal_text() const {
  return _impl_.text_.Get();
}
inline void SCEchoAck::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* SCEchoAck::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* SCEchoAck::release_text() {
  // @@protoc_insertion_point(field_release:SCEchoAck.text)
  return _impl_.text_.Release();
}
inline void SCEchoAck::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SCEchoAck.text)
}

// -------------------------------------------------------------------

// CSEnterGameReq

// -------------------------------------------------------------------

// SCEnterGameAck

// float X = 1;
inline void SCEnterGameAck::clear_x() {
  _impl_.x_ = 0;
}
inline float SCEnterGameAck::_internal_x() const {
  return _impl_.x_;
}
inline float SCEnterGameAck::x() const {
  // @@protoc_insertion_point(field_get:SCEnterGameAck.X)
  return _internal_x();
}
inline void SCEnterGameAck::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void SCEnterGameAck::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:SCEnterGameAck.X)
}

// float Y = 2;
inline void SCEnterGameAck::clear_y() {
  _impl_.y_ = 0;
}
inline float SCEnterGameAck::_internal_y() const {
  return _impl_.y_;
}
inline float SCEnterGameAck::y() const {
  // @@protoc_insertion_point(field_get:SCEnterGameAck.Y)
  return _internal_y();
}
inline void SCEnterGameAck::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void SCEnterGameAck::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:SCEnterGameAck.Y)
}

// -------------------------------------------------------------------

// SCEnterGameNoti

// int64 UniqueID = 1;
inline void SCEnterGameNoti::clear_uniqueid() {
  _impl_.uniqueid_ = int64_t{0};
}
inline int64_t SCEnterGameNoti::_internal_uniqueid() const {
  return _impl_.uniqueid_;
}
inline int64_t SCEnterGameNoti::uniqueid() const {
  // @@protoc_insertion_point(field_get:SCEnterGameNoti.UniqueID)
  return _internal_uniqueid();
}
inline void SCEnterGameNoti::_internal_set_uniqueid(int64_t value) {
  
  _impl_.uniqueid_ = value;
}
inline void SCEnterGameNoti::set_uniqueid(int64_t value) {
  _internal_set_uniqueid(value);
  // @@protoc_insertion_point(field_set:SCEnterGameNoti.UniqueID)
}

// int32 Direction = 2;
inline void SCEnterGameNoti::clear_direction() {
  _impl_.direction_ = 0;
}
inline int32_t SCEnterGameNoti::_internal_direction() const {
  return _impl_.direction_;
}
inline int32_t SCEnterGameNoti::direction() const {
  // @@protoc_insertion_point(field_get:SCEnterGameNoti.Direction)
  return _internal_direction();
}
inline void SCEnterGameNoti::_internal_set_direction(int32_t value) {
  
  _impl_.direction_ = value;
}
inline void SCEnterGameNoti::set_direction(int32_t value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:SCEnterGameNoti.Direction)
}

// bool IsMove = 3;
inline void SCEnterGameNoti::clear_ismove() {
  _impl_.ismove_ = false;
}
inline bool SCEnterGameNoti::_internal_ismove() const {
  return _impl_.ismove_;
}
inline bool SCEnterGameNoti::ismove() const {
  // @@protoc_insertion_point(field_get:SCEnterGameNoti.IsMove)
  return _internal_ismove();
}
inline void SCEnterGameNoti::_internal_set_ismove(bool value) {
  
  _impl_.ismove_ = value;
}
inline void SCEnterGameNoti::set_ismove(bool value) {
  _internal_set_ismove(value);
  // @@protoc_insertion_point(field_set:SCEnterGameNoti.IsMove)
}

// float X = 4;
inline void SCEnterGameNoti::clear_x() {
  _impl_.x_ = 0;
}
inline float SCEnterGameNoti::_internal_x() const {
  return _impl_.x_;
}
inline float SCEnterGameNoti::x() const {
  // @@protoc_insertion_point(field_get:SCEnterGameNoti.X)
  return _internal_x();
}
inline void SCEnterGameNoti::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void SCEnterGameNoti::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:SCEnterGameNoti.X)
}

// float Y = 5;
inline void SCEnterGameNoti::clear_y() {
  _impl_.y_ = 0;
}
inline float SCEnterGameNoti::_internal_y() const {
  return _impl_.y_;
}
inline float SCEnterGameNoti::y() const {
  // @@protoc_insertion_point(field_get:SCEnterGameNoti.Y)
  return _internal_y();
}
inline void SCEnterGameNoti::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void SCEnterGameNoti::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:SCEnterGameNoti.Y)
}

// -------------------------------------------------------------------

// CSMoveReq

// int32 Direction = 1;
inline void CSMoveReq::clear_direction() {
  _impl_.direction_ = 0;
}
inline int32_t CSMoveReq::_internal_direction() const {
  return _impl_.direction_;
}
inline int32_t CSMoveReq::direction() const {
  // @@protoc_insertion_point(field_get:CSMoveReq.Direction)
  return _internal_direction();
}
inline void CSMoveReq::_internal_set_direction(int32_t value) {
  
  _impl_.direction_ = value;
}
inline void CSMoveReq::set_direction(int32_t value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:CSMoveReq.Direction)
}

// -------------------------------------------------------------------

// SCMoveNoti

// int64 UniqueID = 1;
inline void SCMoveNoti::clear_uniqueid() {
  _impl_.uniqueid_ = int64_t{0};
}
inline int64_t SCMoveNoti::_internal_uniqueid() const {
  return _impl_.uniqueid_;
}
inline int64_t SCMoveNoti::uniqueid() const {
  // @@protoc_insertion_point(field_get:SCMoveNoti.UniqueID)
  return _internal_uniqueid();
}
inline void SCMoveNoti::_internal_set_uniqueid(int64_t value) {
  
  _impl_.uniqueid_ = value;
}
inline void SCMoveNoti::set_uniqueid(int64_t value) {
  _internal_set_uniqueid(value);
  // @@protoc_insertion_point(field_set:SCMoveNoti.UniqueID)
}

// int32 Direction = 2;
inline void SCMoveNoti::clear_direction() {
  _impl_.direction_ = 0;
}
inline int32_t SCMoveNoti::_internal_direction() const {
  return _impl_.direction_;
}
inline int32_t SCMoveNoti::direction() const {
  // @@protoc_insertion_point(field_get:SCMoveNoti.Direction)
  return _internal_direction();
}
inline void SCMoveNoti::_internal_set_direction(int32_t value) {
  
  _impl_.direction_ = value;
}
inline void SCMoveNoti::set_direction(int32_t value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:SCMoveNoti.Direction)
}

// float X = 3;
inline void SCMoveNoti::clear_x() {
  _impl_.x_ = 0;
}
inline float SCMoveNoti::_internal_x() const {
  return _impl_.x_;
}
inline float SCMoveNoti::x() const {
  // @@protoc_insertion_point(field_get:SCMoveNoti.X)
  return _internal_x();
}
inline void SCMoveNoti::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void SCMoveNoti::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:SCMoveNoti.X)
}

// float Y = 4;
inline void SCMoveNoti::clear_y() {
  _impl_.y_ = 0;
}
inline float SCMoveNoti::_internal_y() const {
  return _impl_.y_;
}
inline float SCMoveNoti::y() const {
  // @@protoc_insertion_point(field_get:SCMoveNoti.Y)
  return _internal_y();
}
inline void SCMoveNoti::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void SCMoveNoti::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:SCMoveNoti.Y)
}

// -------------------------------------------------------------------

// CSStopReq

// -------------------------------------------------------------------

// SCStopNoti

// int64 UniqueID = 1;
inline void SCStopNoti::clear_uniqueid() {
  _impl_.uniqueid_ = int64_t{0};
}
inline int64_t SCStopNoti::_internal_uniqueid() const {
  return _impl_.uniqueid_;
}
inline int64_t SCStopNoti::uniqueid() const {
  // @@protoc_insertion_point(field_get:SCStopNoti.UniqueID)
  return _internal_uniqueid();
}
inline void SCStopNoti::_internal_set_uniqueid(int64_t value) {
  
  _impl_.uniqueid_ = value;
}
inline void SCStopNoti::set_uniqueid(int64_t value) {
  _internal_set_uniqueid(value);
  // @@protoc_insertion_point(field_set:SCStopNoti.UniqueID)
}

// float X = 2;
inline void SCStopNoti::clear_x() {
  _impl_.x_ = 0;
}
inline float SCStopNoti::_internal_x() const {
  return _impl_.x_;
}
inline float SCStopNoti::x() const {
  // @@protoc_insertion_point(field_get:SCStopNoti.X)
  return _internal_x();
}
inline void SCStopNoti::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void SCStopNoti::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:SCStopNoti.X)
}

// float Y = 3;
inline void SCStopNoti::clear_y() {
  _impl_.y_ = 0;
}
inline float SCStopNoti::_internal_y() const {
  return _impl_.y_;
}
inline float SCStopNoti::y() const {
  // @@protoc_insertion_point(field_get:SCStopNoti.Y)
  return _internal_y();
}
inline void SCStopNoti::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void SCStopNoti::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:SCStopNoti.Y)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
